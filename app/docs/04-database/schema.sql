-- ===========================================
-- SCRIPT MAESTRO UNIFICADO (MULTI-TENANT) - OPTIMIZADO
-- Base de datos completa para la app Flutter
-- Incluye: Auth, Roles, Permisos, Empresas, Sucursales, Interacciones, Reclamos, Módulos, Clientes
-- Optimización: RLS con InitPlan (Select wrappers) + Índices FK
-- ===========================================

-- ===========================================
-- PARTE 0: LIMPIEZA (OPCIONAL - CUIDADO)
-- ===========================================
-- DROP TABLE IF EXISTS historial_reclamos CASCADE;
-- DROP TABLE IF EXISTS clientes CASCADE;
-- DROP TABLE IF EXISTS usuario_modulos CASCADE;
-- DROP TABLE IF EXISTS sucursal_modulos CASCADE;
-- DROP TABLE IF EXISTS empresa_modulos CASCADE;
-- DROP TABLE IF EXISTS modulos CASCADE;
-- DROP TABLE IF EXISTS reclamos CASCADE;
-- DROP TABLE IF EXISTS interacciones CASCADE;
-- DROP TABLE IF EXISTS invitaciones CASCADE;
-- DROP TABLE IF EXISTS usuario_permiso CASCADE;
-- DROP TABLE IF EXISTS permisos CASCADE;
-- DROP TABLE IF EXISTS usuarios CASCADE;
-- DROP TABLE IF EXISTS rol_capacidad CASCADE;
-- DROP TABLE IF EXISTS capacidades CASCADE;
-- DROP TABLE IF EXISTS roles CASCADE;
-- DROP TABLE IF EXISTS sucursales CASCADE;
-- DROP TABLE IF EXISTS empresas CASCADE;

-- ===========================================
-- PARTE 1: EMPRESAS Y SUCURSALES (MULTI-TENANCY)
-- ===========================================

CREATE TABLE IF NOT EXISTS empresas (
    id bigint generated by default as identity primary key,
    nombre text not null,
    codigo text unique not null, 
    logo_url text, 
    color_tema text default '#2196F3', 
    fecha_creacion timestamp with time zone default timezone('utc'::text, now()) not null,
    deleted_at timestamp with time zone 
);

-- ===========================================
-- TABLA: empresa_branding (Theming Multi-Tenant)
-- ===========================================

CREATE TABLE IF NOT EXISTS empresa_branding (
  id SERIAL PRIMARY KEY,
  empresa_id INTEGER REFERENCES empresas(id) ON DELETE CASCADE UNIQUE NOT NULL,
  
  -- Colores (formato hex: #RRGGBB)
  color_primario VARCHAR(7) DEFAULT '#1976D2' NOT NULL,
  color_secundario VARCHAR(7) DEFAULT '#DC004E' NOT NULL,
  color_acento VARCHAR(7) DEFAULT '#FFC107' NOT NULL,
  
  -- Logo URL (Supabase Storage)
  logo_url TEXT,
  logo_light_url TEXT,
  favicon_url TEXT,
  
  -- Tipografía
  fuente_primaria VARCHAR(50) DEFAULT 'Roboto' NOT NULL,
  
  -- Dark Mode
  dark_mode_habilitado BOOLEAN DEFAULT true NOT NULL,
  color_primario_dark VARCHAR(7),
  color_secundario_dark VARCHAR(7),
  
  -- Timestamps
  fecha_creacion TIMESTAMP DEFAULT NOW() NOT NULL,
  actualizado_en TIMESTAMP DEFAULT NOW() NOT NULL
);

CREATE INDEX idx_empresa_branding_empresa ON empresa_branding(empresa_id);

CREATE TABLE IF NOT EXISTS sucursales (
    id bigint generated by default as identity primary key,
    empresa_id bigint references empresas(id) on delete cascade not null,
    nombre text not null,
    direccion text,
    fecha_creacion timestamp with time zone default timezone('utc'::text, now()) not null,
    deleted_at timestamp with time zone
);

-- ===========================================
-- PARTE 2: ROLES Y CAPACIDADES
-- ===========================================

CREATE TABLE IF NOT EXISTS roles (
    id SERIAL PRIMARY KEY,
    nombre TEXT UNIQUE NOT NULL,
    descripcion TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS capacidades (
    id SERIAL PRIMARY KEY,
    nombre TEXT UNIQUE NOT NULL,
    descripcion TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS rol_capacidad (
    rol_id INTEGER REFERENCES roles(id) ON DELETE CASCADE,
    capacidad_id INTEGER REFERENCES capacidades(id) ON DELETE CASCADE,
    PRIMARY KEY (rol_id, capacidad_id)
);

INSERT INTO roles (nombre, descripcion) VALUES
    ('super_admin', 'Dueño de la Plataforma (Acceso Total)'),
    ('admin', 'Administrador de Empresa'),
    ('gerente', 'Gerente de Sucursal'),
    ('usuario', 'Usuario regular / Staff'),
    ('cliente', 'Cliente final')
ON CONFLICT (nombre) DO NOTHING;

INSERT INTO capacidades (nombre, descripcion) VALUES
    ('publicar', 'Puede publicar contenidos'),
    ('editar', 'Puede editar contenidos'),
    ('borrar', 'Puede borrar contenidos'),
    ('leer', 'Puede leer contenidos'),
    ('gestionar_empresa', 'Puede gestionar datos de la empresa')
ON CONFLICT (nombre) DO NOTHING;

-- Asignar capacidades a roles
INSERT INTO rol_capacidad (rol_id, capacidad_id)
SELECT r.id, c.id FROM roles r CROSS JOIN capacidades c WHERE r.nombre = 'super_admin'
ON CONFLICT (rol_id, capacidad_id) DO NOTHING;

INSERT INTO rol_capacidad (rol_id, capacidad_id)
SELECT r.id, c.id FROM roles r CROSS JOIN capacidades c 
WHERE r.nombre = 'admin' AND c.nombre IN ('gestionar_empresa', 'editar', 'borrar', 'leer')
ON CONFLICT (rol_id, capacidad_id) DO NOTHING;

INSERT INTO rol_capacidad (rol_id, capacidad_id)
SELECT r.id, c.id FROM roles r CROSS JOIN capacidades c 
WHERE r.nombre = 'gerente' AND c.nombre IN ('editar', 'leer', 'publicar')
ON CONFLICT (rol_id, capacidad_id) DO NOTHING;

INSERT INTO rol_capacidad (rol_id, capacidad_id)
SELECT r.id, c.id FROM roles r CROSS JOIN capacidades c 
WHERE r.nombre = 'usuario' AND c.nombre IN ('leer', 'publicar')
ON CONFLICT (rol_id, capacidad_id) DO NOTHING;

INSERT INTO rol_capacidad (rol_id, capacidad_id)
SELECT r.id, c.id FROM roles r CROSS JOIN capacidades c 
WHERE r.nombre = 'cliente' AND c.nombre = 'leer'
ON CONFLICT (rol_id, capacidad_id) DO NOTHING;

-- ===========================================
-- PARTE 3: USUARIOS (CON MULTI-TENANCY)
-- ===========================================

CREATE TABLE IF NOT EXISTS usuarios (
    id uuid PRIMARY KEY, 
    email TEXT UNIQUE NOT NULL,
    username TEXT,
    nombre TEXT,
    apellido TEXT,
    telefono TEXT,
    direccion TEXT,
    documento_identidad TEXT,
    tipo_perfil TEXT NOT NULL DEFAULT 'usuario',
    rol_id INTEGER REFERENCES roles(id),
    empresa_id bigint references empresas(id) on delete cascade,
    sucursal_id bigint references sucursales(id) on delete set null,
    creado_en TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS invitaciones (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    email text UNIQUE NOT NULL,
    empresa_id bigint REFERENCES empresas(id) ON DELETE CASCADE NOT NULL,
    sucursal_id bigint REFERENCES sucursales(id) ON DELETE SET NULL,
    rol_id integer REFERENCES roles(id) NOT NULL,
    creado_por uuid REFERENCES auth.users,
    fecha_creacion timestamptz DEFAULT now()
);

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
  v_invitacion record;
  v_rol_id integer;
BEGIN
  SELECT * INTO v_invitacion FROM public.invitaciones WHERE email = NEW.email;

  IF v_invitacion IS NOT NULL THEN
     INSERT INTO public.usuarios (id, email, username, nombre, apellido, telefono, direccion, documento_identidad, tipo_perfil, rol_id, empresa_id, sucursal_id)
     VALUES (
        NEW.id, 
        NEW.email,
        NEW.raw_user_meta_data->>'username', 
        COALESCE(NEW.raw_user_meta_data->>'nombre', split_part(NEW.email, '@', 1)),
        NEW.raw_user_meta_data->>'apellido',
        NEW.raw_user_meta_data->>'telefono',
        NEW.raw_user_meta_data->>'direccion',
        NEW.raw_user_meta_data->>'documento_identidad',
        'usuario', 
        v_invitacion.rol_id, 
        v_invitacion.empresa_id, 
        v_invitacion.sucursal_id 
     );
     DELETE FROM public.invitaciones WHERE id = v_invitacion.id;
  ELSE
     SELECT id INTO v_rol_id FROM public.roles WHERE nombre = 'usuario' LIMIT 1;
     INSERT INTO public.usuarios (id, email, username, nombre, apellido, telefono, direccion, documento_identidad, tipo_perfil, rol_id)
     VALUES (
        NEW.id, 
        NEW.email, 
        NEW.raw_user_meta_data->>'username', 
        COALESCE(NEW.raw_user_meta_data->>'nombre', split_part(NEW.email, '@', 1)),
        NEW.raw_user_meta_data->>'apellido',
        NEW.raw_user_meta_data->>'telefono',
        NEW.raw_user_meta_data->>'direccion',
        NEW.raw_user_meta_data->>'documento_identidad',
        'usuario',
        v_rol_id
     );
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- ===========================================
-- PARTE 4: PERMISOS INDIVIDUALES
-- ===========================================

CREATE TABLE IF NOT EXISTS permisos (
    id SERIAL PRIMARY KEY,
    nombre TEXT UNIQUE NOT NULL,
    descripcion TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS usuario_permiso (
    usuario_id uuid REFERENCES usuarios(id) ON DELETE CASCADE,
    permiso_id INTEGER REFERENCES permisos(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    PRIMARY KEY (usuario_id, permiso_id)
);

INSERT INTO permisos (nombre, descripcion) VALUES
    ('acceso_panel', 'Acceso al panel principal'),
    ('ver_reportes', 'Permite ver reportes'),
    ('editar_usuarios', 'Permite editar usuarios'),
    ('crear_usuarios', 'Permite crear usuarios'),
    ('eliminar_usuarios', 'Permite eliminar usuarios'),
    ('ver_reclamos', 'Permite ver reclamos'),
    ('gestionar_reclamos', 'Permite crear y editar reclamos'),
    ('gestionar_empresa', 'Permite gestionar datos de la empresa')
ON CONFLICT (nombre) DO NOTHING;

-- ===========================================
-- ===========================================
-- PARTE 5: INTERACCIONES Y RECLAMOS
-- ===========================================

-- 5.1 Tipos Dinámicos

CREATE TABLE IF NOT EXISTS tipos_reclamo (
    id SERIAL PRIMARY KEY,
    empresa_id bigint REFERENCES empresas(id) ON DELETE CASCADE NOT NULL,
    nombre TEXT NOT NULL,
    descripcion TEXT,
    prioridad_default TEXT DEFAULT 'media',
    campos_requeridos JSONB DEFAULT '[]',
    activo BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(empresa_id, nombre)
);
ALTER TABLE tipos_reclamo ENABLE ROW LEVEL SECURITY;

CREATE TABLE IF NOT EXISTS tipos_interaccion (
    id SERIAL PRIMARY KEY,
    empresa_id bigint REFERENCES empresas(id) ON DELETE CASCADE NOT NULL,
    nombre TEXT NOT NULL,
    descripcion TEXT,
    activo BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(empresa_id, nombre)
);
ALTER TABLE tipos_interaccion ENABLE ROW LEVEL SECURITY;

-- 5.2 Tablas Principales

CREATE TABLE IF NOT EXISTS interacciones (
  id bigint generated by default as identity primary key,
  usuario_id uuid references auth.users not null,
  empresa_id bigint references empresas(id) on delete cascade,
  tipo text not null, -- Legacy
  tipo_interaccion_id integer REFERENCES tipos_interaccion(id) ON DELETE SET NULL,
  descripcion text,
  datos_extra jsonb,
  fecha timestamp with time zone default timezone('utc'::text, now()) not null
);

CREATE TABLE IF NOT EXISTS reclamos (
  id bigint generated by default as identity primary key,
  usuario_id uuid references auth.users not null,
  empresa_id bigint references empresas(id) on delete cascade,
  sucursal_id bigint references sucursales(id) on delete set null,
  cliente_id bigint, 
  tipo_reclamo_id integer REFERENCES tipos_reclamo(id) ON DELETE SET NULL,
  titulo text not null,
  descripcion text,
  estado text not null default 'pendiente',
  prioridad text default 'media',
  datos_extra jsonb,
  fecha_creacion timestamp with time zone default timezone('utc'::text, now()) not null,
  fecha_actualizacion timestamp with time zone default timezone('utc'::text, now()) not null
);

CREATE TABLE IF NOT EXISTS historial_reclamos (
  id bigint generated by default as identity primary key,
  reclamo_id bigint references reclamos(id) on delete cascade,
  usuario_id uuid references auth.users,
  tipo_accion text,
  descripcion text,
  fecha timestamp with time zone default now(),
  datos_cambio jsonb
);

-- ===========================================
-- PARTE 6: ROW LEVEL SECURITY (RLS) - OPTIMIZADO
-- ===========================================

ALTER TABLE empresas ENABLE ROW LEVEL SECURITY;
ALTER TABLE sucursales ENABLE ROW LEVEL SECURITY;
ALTER TABLE usuarios ENABLE ROW LEVEL SECURITY;
ALTER TABLE interacciones ENABLE ROW LEVEL SECURITY;
ALTER TABLE reclamos ENABLE ROW LEVEL SECURITY;
ALTER TABLE invitaciones ENABLE ROW LEVEL SECURITY;
ALTER TABLE roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE capacidades ENABLE ROW LEVEL SECURITY;
ALTER TABLE rol_capacidad ENABLE ROW LEVEL SECURITY;
ALTER TABLE permisos ENABLE ROW LEVEL SECURITY;
ALTER TABLE usuario_permiso ENABLE ROW LEVEL SECURITY;

-- Funciones Auxiliares (Wrappers)
CREATE OR REPLACE FUNCTION public.mi_empresa_id()
RETURNS bigint AS $$
BEGIN
  RETURN (SELECT empresa_id FROM usuarios WHERE id = auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

CREATE OR REPLACE FUNCTION public.es_super_admin()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM usuarios 
    WHERE id = auth.uid() 
    AND tipo_perfil = 'super_admin'
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

CREATE OR REPLACE FUNCTION public.es_admin()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM usuarios u
    LEFT JOIN roles r ON u.rol_id = r.id
    WHERE u.id = auth.uid() 
    AND (
      u.tipo_perfil IN ('admin', 'super_admin') 
      OR r.nombre = 'admin'
    )
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

-- === POLICIES: EMPRESAS ===

DROP POLICY IF EXISTS "select_empresas_unificada" ON empresas;
CREATE POLICY "select_empresas_unificada" ON empresas
FOR SELECT TO authenticated USING (id = (SELECT public.mi_empresa_id()) OR (SELECT public.es_super_admin()));

DROP POLICY IF EXISTS "update_empresas_unificada" ON empresas;
CREATE POLICY "update_empresas_unificada" ON empresas
FOR UPDATE TO authenticated USING ((SELECT public.es_super_admin())); -- Solo super admin edita empresas base por ahora

DROP POLICY IF EXISTS "insert_empresas_unificada" ON empresas;
CREATE POLICY "insert_empresas_unificada" ON empresas
FOR INSERT TO authenticated WITH CHECK ((SELECT public.es_super_admin()));

DROP POLICY IF EXISTS "delete_empresas_unificada" ON empresas;
CREATE POLICY "delete_empresas_unificada" ON empresas
FOR DELETE TO authenticated USING ((SELECT public.es_super_admin()));

-- === POLICIES: SUCURSALES ===

DROP POLICY IF EXISTS "select_sucursales_unificada" ON sucursales;
CREATE POLICY "select_sucursales_unificada" ON sucursales
FOR SELECT TO authenticated USING (
  empresa_id = (SELECT public.mi_empresa_id()) OR (SELECT public.es_super_admin())
);

DROP POLICY IF EXISTS "insert_sucursales_unificada" ON sucursales;
CREATE POLICY "insert_sucursales_unificada" ON sucursales
FOR INSERT TO authenticated WITH CHECK (
  (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin()))
  OR (SELECT public.es_super_admin())
);
DROP POLICY IF EXISTS "update_sucursales_unificada" ON sucursales;
CREATE POLICY "update_sucursales_unificada" ON sucursales
FOR UPDATE TO authenticated USING (
  (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin()))
  OR (SELECT public.es_super_admin())
) WITH CHECK (
  (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin()))
  OR (SELECT public.es_super_admin())
);
DROP POLICY IF EXISTS "delete_sucursales_unificada" ON sucursales;
CREATE POLICY "delete_sucursales_unificada" ON sucursales
FOR DELETE TO authenticated USING (
  (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin()))
  OR (SELECT public.es_super_admin())
);

-- === POLICIES: USUARIOS ===
DROP POLICY IF EXISTS "select_usuarios_unificada" ON usuarios;
CREATE POLICY "select_usuarios_unificada" ON usuarios
FOR SELECT TO authenticated USING (
  (SELECT public.es_super_admin())
  OR id = (SELECT auth.uid())
  OR (empresa_id = (SELECT public.mi_empresa_id()))
);

DROP POLICY IF EXISTS "update_usuarios_unificada" ON usuarios;
CREATE POLICY "update_usuarios_unificada" ON usuarios
FOR UPDATE TO authenticated USING (
  (SELECT public.es_super_admin())
  OR id = (SELECT auth.uid())
  OR (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin()))
)
WITH CHECK (
  (SELECT public.es_super_admin())
  OR id = (SELECT auth.uid())
  OR (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin()))
);

DROP POLICY IF EXISTS "delete_usuarios_unificada" ON usuarios;
CREATE POLICY "delete_usuarios_unificada" ON usuarios
FOR DELETE TO authenticated USING (
  (SELECT public.es_super_admin())
  OR (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin()))
);



-- === POLICIES: INTERACCIONES ===

DROP POLICY IF EXISTS "select_interacciones_unificada" ON interacciones;
CREATE POLICY "select_interacciones_unificada" ON interacciones
FOR SELECT TO authenticated USING (empresa_id = (SELECT public.mi_empresa_id()) OR (SELECT public.es_super_admin()));

DROP POLICY IF EXISTS "insert_interacciones_unificada" ON interacciones;
CREATE POLICY "insert_interacciones_unificada" ON interacciones
FOR INSERT TO authenticated WITH CHECK (empresa_id = (SELECT public.mi_empresa_id()) OR (SELECT public.es_super_admin()));

-- === POLICIES: RECLAMOS ===

DROP POLICY IF EXISTS "Gestionar reclamos de mi empresa" ON reclamos; 

DROP POLICY IF EXISTS "select_reclamos_unificada" ON reclamos;
CREATE POLICY "select_reclamos_unificada" ON reclamos
FOR SELECT TO authenticated USING (
  empresa_id = (SELECT public.mi_empresa_id()) OR (SELECT public.es_super_admin())
);

DROP POLICY IF EXISTS "insert_reclamos_unificada" ON reclamos;
CREATE POLICY "insert_reclamos_unificada" ON reclamos
FOR INSERT TO authenticated WITH CHECK (
  empresa_id = (SELECT public.mi_empresa_id()) OR (SELECT public.es_super_admin())
);

DROP POLICY IF EXISTS "update_reclamos_unificada" ON reclamos;
CREATE POLICY "update_reclamos_unificada" ON reclamos
FOR UPDATE TO authenticated USING (
  empresa_id = (SELECT public.mi_empresa_id()) OR (SELECT public.es_super_admin())
) WITH CHECK (
  empresa_id = (SELECT public.mi_empresa_id()) OR (SELECT public.es_super_admin())
);

DROP POLICY IF EXISTS "delete_reclamos_unificada" ON reclamos;
CREATE POLICY "delete_reclamos_unificada" ON reclamos
FOR DELETE TO authenticated USING (
  (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin())) 
  OR (SELECT public.es_super_admin())
);

-- === POLICIES: TIPOS DINÁMICOS ===

DROP POLICY IF EXISTS "select_tipos_reclamo_unificada" ON tipos_reclamo;
CREATE POLICY "select_tipos_reclamo_unificada" ON tipos_reclamo
FOR SELECT TO authenticated USING (empresa_id = (SELECT public.mi_empresa_id()) OR (SELECT public.es_super_admin()));

DROP POLICY IF EXISTS "insert_tipos_reclamo_unificada" ON tipos_reclamo;
CREATE POLICY "insert_tipos_reclamo_unificada" ON tipos_reclamo
FOR INSERT TO authenticated WITH CHECK (
  (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin()))
  OR (SELECT public.es_super_admin())
);

DROP POLICY IF EXISTS "update_tipos_reclamo_unificada" ON tipos_reclamo;
CREATE POLICY "update_tipos_reclamo_unificada" ON tipos_reclamo
FOR UPDATE TO authenticated USING (
  (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin()))
  OR (SELECT public.es_super_admin())
) WITH CHECK (
  (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin()))
  OR (SELECT public.es_super_admin())
);

DROP POLICY IF EXISTS "delete_tipos_reclamo_unificada" ON tipos_reclamo;
CREATE POLICY "delete_tipos_reclamo_unificada" ON tipos_reclamo
FOR DELETE TO authenticated USING (
  (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin()))
  OR (SELECT public.es_super_admin())
);

DROP POLICY IF EXISTS "select_tipos_interaccion_unificada" ON tipos_interaccion;
CREATE POLICY "select_tipos_interaccion_unificada" ON tipos_interaccion
FOR SELECT TO authenticated USING (empresa_id = (SELECT public.mi_empresa_id()) OR (SELECT public.es_super_admin()));

DROP POLICY IF EXISTS "insert_tipos_interaccion_unificada" ON tipos_interaccion;
CREATE POLICY "insert_tipos_interaccion_unificada" ON tipos_interaccion
FOR INSERT TO authenticated WITH CHECK (
  (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin()))
  OR (SELECT public.es_super_admin())
);

DROP POLICY IF EXISTS "update_tipos_interaccion_unificada" ON tipos_interaccion;
CREATE POLICY "update_tipos_interaccion_unificada" ON tipos_interaccion
FOR UPDATE TO authenticated USING (
  (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin()))
  OR (SELECT public.es_super_admin())
) WITH CHECK (
  (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin()))
  OR (SELECT public.es_super_admin())
);

DROP POLICY IF EXISTS "delete_tipos_interaccion_unificada" ON tipos_interaccion;
CREATE POLICY "delete_tipos_interaccion_unificada" ON tipos_interaccion
FOR DELETE TO authenticated USING (
  (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin()))
  OR (SELECT public.es_super_admin())
);

-- === POLICIES: HISTORIAL RECLAMOS ===

ALTER TABLE historial_reclamos ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "select_historial_reclamos_unificada" ON historial_reclamos;
CREATE POLICY "select_historial_reclamos_unificada" ON historial_reclamos
FOR SELECT TO authenticated USING (
  EXISTS (
    SELECT 1 FROM reclamos r 
    WHERE r.id = historial_reclamos.reclamo_id 
    AND (r.empresa_id = (SELECT public.mi_empresa_id()) OR (SELECT public.es_super_admin()))
  )
);

DROP POLICY IF EXISTS "insert_historial_reclamos_unificada" ON historial_reclamos;
CREATE POLICY "insert_historial_reclamos_unificada" ON historial_reclamos
FOR INSERT TO authenticated WITH CHECK (
  -- Permitir insertar si el usuario tiene acceso al reclamo padre (simplificado: authenticated)
  (SELECT auth.role()) = 'authenticated'
);



-- === POLICIES: INVITACIONES ===

DROP POLICY IF EXISTS "select_invitaciones_unificada" ON invitaciones;
CREATE POLICY "select_invitaciones_unificada" ON invitaciones
FOR SELECT TO authenticated USING (empresa_id = (SELECT public.mi_empresa_id()) OR (SELECT public.es_super_admin()));

DROP POLICY IF EXISTS "insert_invitaciones_unificada" ON invitaciones;
CREATE POLICY "insert_invitaciones_unificada" ON invitaciones
FOR INSERT TO authenticated WITH CHECK (empresa_id = (SELECT public.mi_empresa_id()) OR (SELECT public.es_super_admin()));

DROP POLICY IF EXISTS "delete_invitaciones_unificada" ON invitaciones;
CREATE POLICY "delete_invitaciones_unificada" ON invitaciones
FOR DELETE TO authenticated USING (empresa_id = (SELECT public.mi_empresa_id()) OR (SELECT public.es_super_admin()));

-- === POLICIES: METADATA (ROLES, CAPACIDADES, PERMISOS, ROL_CAPACIDAD) ===

-- ROLES
DROP POLICY IF EXISTS "select_roles_unificada" ON roles;
CREATE POLICY "select_roles_unificada" ON roles FOR SELECT TO authenticated USING (true);
DROP POLICY IF EXISTS "insert_roles_unificada" ON roles;
CREATE POLICY "insert_roles_unificada" ON roles FOR INSERT TO authenticated WITH CHECK ((SELECT public.es_super_admin()));
DROP POLICY IF EXISTS "update_roles_unificada" ON roles;
CREATE POLICY "update_roles_unificada" ON roles FOR UPDATE TO authenticated USING ((SELECT public.es_super_admin())) WITH CHECK ((SELECT public.es_super_admin()));
DROP POLICY IF EXISTS "delete_roles_unificada" ON roles;
CREATE POLICY "delete_roles_unificada" ON roles FOR DELETE TO authenticated USING ((SELECT public.es_super_admin()));


-- CAPACIDADES
DROP POLICY IF EXISTS "select_capacidades_unificada" ON capacidades;
CREATE POLICY "select_capacidades_unificada" ON capacidades FOR SELECT TO authenticated USING (true); 
DROP POLICY IF EXISTS "insert_capacidades_unificada" ON capacidades;
CREATE POLICY "insert_capacidades_unificada" ON capacidades FOR INSERT TO authenticated WITH CHECK ((SELECT public.es_super_admin()));
DROP POLICY IF EXISTS "update_capacidades_unificada" ON capacidades;
CREATE POLICY "update_capacidades_unificada" ON capacidades FOR UPDATE TO authenticated USING ((SELECT public.es_super_admin())) WITH CHECK ((SELECT public.es_super_admin()));
DROP POLICY IF EXISTS "delete_capacidades_unificada" ON capacidades;
CREATE POLICY "delete_capacidades_unificada" ON capacidades FOR DELETE TO authenticated USING ((SELECT public.es_super_admin()));


-- PERMISOS
DROP POLICY IF EXISTS "select_permisos_unificada" ON permisos;
CREATE POLICY "select_permisos_unificada" ON permisos FOR SELECT TO authenticated USING (true);
DROP POLICY IF EXISTS "insert_permisos_unificada" ON permisos;
CREATE POLICY "insert_permisos_unificada" ON permisos FOR INSERT TO authenticated WITH CHECK ((SELECT public.es_super_admin()));
DROP POLICY IF EXISTS "update_permisos_unificada" ON permisos;
CREATE POLICY "update_permisos_unificada" ON permisos FOR UPDATE TO authenticated USING ((SELECT public.es_super_admin())) WITH CHECK ((SELECT public.es_super_admin()));
DROP POLICY IF EXISTS "delete_permisos_unificada" ON permisos;
CREATE POLICY "delete_permisos_unificada" ON permisos FOR DELETE TO authenticated USING ((SELECT public.es_super_admin()));


-- USUARIO_PERMISO (Consolidada)
DROP POLICY IF EXISTS "select_usuario_permiso_unificada" ON usuario_permiso;
CREATE POLICY "select_usuario_permiso_unificada" ON usuario_permiso
FOR SELECT TO authenticated USING (
  usuario_id = (SELECT auth.uid())
  OR (SELECT public.es_super_admin())
);
DROP POLICY IF EXISTS "insert_usuario_permiso_unificada" ON usuario_permiso;
CREATE POLICY "insert_usuario_permiso_unificada" ON usuario_permiso FOR INSERT TO authenticated WITH CHECK ((SELECT public.es_super_admin()));
DROP POLICY IF EXISTS "update_usuario_permiso_unificada" ON usuario_permiso;
CREATE POLICY "update_usuario_permiso_unificada" ON usuario_permiso FOR UPDATE TO authenticated USING ((SELECT public.es_super_admin())) WITH CHECK ((SELECT public.es_super_admin()));
DROP POLICY IF EXISTS "delete_usuario_permiso_unificada" ON usuario_permiso;
CREATE POLICY "delete_usuario_permiso_unificada" ON usuario_permiso FOR DELETE TO authenticated USING ((SELECT public.es_super_admin()));


-- ROL_CAPACIDAD
DROP POLICY IF EXISTS "select_rol_capacidad_unificada" ON rol_capacidad;
CREATE POLICY "select_rol_capacidad_unificada" ON rol_capacidad FOR SELECT TO authenticated USING (true);
DROP POLICY IF EXISTS "insert_rol_capacidad_unificada" ON rol_capacidad;
CREATE POLICY "insert_rol_capacidad_unificada" ON rol_capacidad FOR INSERT TO authenticated WITH CHECK ((SELECT public.es_super_admin()));
DROP POLICY IF EXISTS "update_rol_capacidad_unificada" ON rol_capacidad;
CREATE POLICY "update_rol_capacidad_unificada" ON rol_capacidad FOR UPDATE TO authenticated USING ((SELECT public.es_super_admin())) WITH CHECK ((SELECT public.es_super_admin()));
DROP POLICY IF EXISTS "delete_rol_capacidad_unificada" ON rol_capacidad;
CREATE POLICY "delete_rol_capacidad_unificada" ON rol_capacidad FOR DELETE TO authenticated USING ((SELECT public.es_super_admin()));


-- ===========================================
-- PARTE 7: SISTEMA DE MÓDULOS (MARKETPLACE)
-- ===========================================

CREATE TABLE IF NOT EXISTS modulos (
    id SERIAL PRIMARY KEY,
    codigo TEXT UNIQUE NOT NULL, 
    nombre TEXT NOT NULL,
    descripcion TEXT,
    precio DECIMAL(10, 2) DEFAULT 0.00,
    icono TEXT,
    activo BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS empresa_modulos (
    id SERIAL PRIMARY KEY,
    empresa_id BIGINT REFERENCES empresas(id) ON DELETE CASCADE NOT NULL,
    modulo_id INTEGER REFERENCES modulos(id) ON DELETE CASCADE NOT NULL,
    fecha_activacion TIMESTAMPTZ DEFAULT NOW(),
    fecha_expiracion TIMESTAMPTZ,
    activo BOOLEAN DEFAULT TRUE,
    UNIQUE(empresa_id, modulo_id)
);

ALTER TABLE modulos ENABLE ROW LEVEL SECURITY;
ALTER TABLE empresa_modulos ENABLE ROW LEVEL SECURITY;

-- Policies: MODULOS (Consolidada)
DROP POLICY IF EXISTS "Ver catálogo de módulos" ON modulos;
DROP POLICY IF EXISTS "Super Admin gestiona módulos" ON modulos;

DROP POLICY IF EXISTS "select_modulos_unificada" ON modulos;
CREATE POLICY "select_modulos_unificada" ON modulos
FOR SELECT TO authenticated USING (true); 

DROP POLICY IF EXISTS "insert_modulos_unificada" ON modulos;
CREATE POLICY "insert_modulos_unificada" ON modulos
FOR INSERT TO authenticated WITH CHECK ((SELECT public.es_super_admin()));

DROP POLICY IF EXISTS "update_modulos_unificada" ON modulos;
CREATE POLICY "update_modulos_unificada" ON modulos
FOR UPDATE TO authenticated USING ((SELECT public.es_super_admin())) WITH CHECK ((SELECT public.es_super_admin()));

DROP POLICY IF EXISTS "delete_modulos_unificada" ON modulos;
CREATE POLICY "delete_modulos_unificada" ON modulos
FOR DELETE TO authenticated USING ((SELECT public.es_super_admin()));


-- Policies: EMPRESA_MODULOS (Consolidada)
DROP POLICY IF EXISTS "Ver módulos de mi empresa" ON empresa_modulos;
DROP POLICY IF EXISTS "Admin gestiona módulos de su empresa" ON empresa_modulos;
DROP POLICY IF EXISTS "Super Admin gestiona empresa_modulos" ON empresa_modulos;

DROP POLICY IF EXISTS "select_empresa_modulos_unificada" ON empresa_modulos;
CREATE POLICY "select_empresa_modulos_unificada" ON empresa_modulos
FOR SELECT TO authenticated USING (
  empresa_id = (SELECT public.mi_empresa_id()) OR (SELECT public.es_super_admin())
);

DROP POLICY IF EXISTS "insert_empresa_modulos_unificada" ON empresa_modulos;
CREATE POLICY "insert_empresa_modulos_unificada" ON empresa_modulos
FOR INSERT TO authenticated WITH CHECK (
  (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin())) 
  OR (SELECT public.es_super_admin())
);

DROP POLICY IF EXISTS "update_empresa_modulos_unificada" ON empresa_modulos;
CREATE POLICY "update_empresa_modulos_unificada" ON empresa_modulos
FOR UPDATE TO authenticated USING (
  (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin())) 
  OR (SELECT public.es_super_admin())
) WITH CHECK (
  (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin())) 
  OR (SELECT public.es_super_admin())
);

DROP POLICY IF EXISTS "delete_empresa_modulos_unificada" ON empresa_modulos;
CREATE POLICY "delete_empresa_modulos_unificada" ON empresa_modulos
FOR DELETE TO authenticated USING (
  (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin())) 
  OR (SELECT public.es_super_admin())
);


INSERT INTO modulos (codigo, nombre, descripcion, icono, precio) VALUES
('reclamos', 'Sistema de Reclamos', 'Permite a tus clientes y empleados registrar y gestionar reclamos.', 'report_problem', 0.00),
('interacciones', 'CRM de Interacciones', 'Registra cada punto de contacto con tus clientes.', 'history', 0.00),
('inventario', 'Gestión de Inventario', 'Control de stock y productos (Próximamente).', 'inventory', 10.00),
('dashboard', 'Dashboard Principal', 'Visualización de métricas y resúmenes.', 'dashboard', 0.00),
('speech_to_text', 'Speech-to-Text Backend', 'Transcripción de audio a texto con Whisper AI', 'mic', 30.00)
ON CONFLICT (codigo) DO NOTHING;

-- ===========================================
-- PARTE 8: MÓDULOS GRANULARES
-- ===========================================

CREATE TABLE IF NOT EXISTS sucursal_modulos (
    id SERIAL PRIMARY KEY,
    sucursal_id INTEGER REFERENCES sucursales(id) ON DELETE CASCADE,
    modulo_codigo TEXT REFERENCES modulos(codigo) ON DELETE CASCADE,
    precio_personalizado DECIMAL(10, 2) DEFAULT NULL,
    fecha_activacion TIMESTAMPTZ DEFAULT NOW(),
    activo BOOLEAN DEFAULT TRUE,
    UNIQUE(sucursal_id, modulo_codigo)
);

CREATE TABLE IF NOT EXISTS usuario_modulos (
    id SERIAL PRIMARY KEY,
    usuario_id UUID REFERENCES usuarios(id) ON DELETE CASCADE,
    modulo_codigo TEXT REFERENCES modulos(codigo) ON DELETE CASCADE,
    precio_personalizado DECIMAL(10, 2) DEFAULT NULL,
    fecha_activacion TIMESTAMPTZ DEFAULT NOW(),
    activo BOOLEAN DEFAULT TRUE,
    UNIQUE(usuario_id, modulo_codigo)
);

ALTER TABLE sucursal_modulos ENABLE ROW LEVEL SECURITY;
ALTER TABLE usuario_modulos ENABLE ROW LEVEL SECURITY;

-- Policies: Sucursal Modulos (Consolidada)
DROP POLICY IF EXISTS "Ver módulos de mi sucursal" ON sucursal_modulos;
DROP POLICY IF EXISTS "Admin gestiona módulos de sucursales" ON sucursal_modulos;

DROP POLICY IF EXISTS "select_sucursal_modulos_unificada" ON sucursal_modulos;
CREATE POLICY "select_sucursal_modulos_unificada" ON sucursal_modulos
    FOR SELECT TO authenticated
    USING (
        (SELECT public.es_super_admin())
        OR
        sucursal_id IN (
            SELECT sucursal_id FROM usuarios WHERE id = (SELECT auth.uid())
        )
        OR
        sucursal_id IN (
            SELECT id FROM sucursales WHERE empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin())
        )
    );

DROP POLICY IF EXISTS "insert_sucursal_modulos_unificada" ON sucursal_modulos;
CREATE POLICY "insert_sucursal_modulos_unificada" ON sucursal_modulos
    FOR INSERT TO authenticated
    WITH CHECK (
        (SELECT public.es_super_admin())
        OR
        sucursal_id IN (
            SELECT id FROM sucursales WHERE empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin())
        )
    );

DROP POLICY IF EXISTS "update_sucursal_modulos_unificada" ON sucursal_modulos;
CREATE POLICY "update_sucursal_modulos_unificada" ON sucursal_modulos
    FOR UPDATE TO authenticated
    USING (
        (SELECT public.es_super_admin())
        OR
        sucursal_id IN (
            SELECT id FROM sucursales WHERE empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin())
        )
    ) WITH CHECK (
        (SELECT public.es_super_admin())
        OR
        sucursal_id IN (
            SELECT id FROM sucursales WHERE empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin())
        )
    );

DROP POLICY IF EXISTS "delete_sucursal_modulos_unificada" ON sucursal_modulos;
CREATE POLICY "delete_sucursal_modulos_unificada" ON sucursal_modulos
    FOR DELETE TO authenticated
    USING (
        (SELECT public.es_super_admin())
        OR
        sucursal_id IN (
            SELECT id FROM sucursales WHERE empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin())
        )
    );


-- Policies: Usuario Modulos (Consolidada)
DROP POLICY IF EXISTS "Ver módulos propios" ON usuario_modulos;
DROP POLICY IF EXISTS "Admin gestiona módulos de usuarios" ON usuario_modulos;

DROP POLICY IF EXISTS "select_usuario_modulos_unificada" ON usuario_modulos;
CREATE POLICY "select_usuario_modulos_unificada" ON usuario_modulos
FOR SELECT TO authenticated USING (
   (SELECT public.es_super_admin())
   OR usuario_id = (SELECT auth.uid())
   OR usuario_id IN (
       SELECT id FROM usuarios WHERE empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin())
   )
);

DROP POLICY IF EXISTS "insert_usuario_modulos_unificada" ON usuario_modulos;
CREATE POLICY "insert_usuario_modulos_unificada" ON usuario_modulos
FOR INSERT TO authenticated WITH CHECK (
   (SELECT public.es_super_admin())
   OR usuario_id IN (
       SELECT id FROM usuarios WHERE empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin())
   )
);

DROP POLICY IF EXISTS "update_usuario_modulos_unificada" ON usuario_modulos;
CREATE POLICY "update_usuario_modulos_unificada" ON usuario_modulos
FOR UPDATE TO authenticated USING (
   (SELECT public.es_super_admin())
   OR usuario_id IN (
       SELECT id FROM usuarios WHERE empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin())
   )
) WITH CHECK (
   (SELECT public.es_super_admin())
   OR usuario_id IN (
       SELECT id FROM usuarios WHERE empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin())
   )
);

DROP POLICY IF EXISTS "delete_usuario_modulos_unificada" ON usuario_modulos;
CREATE POLICY "delete_usuario_modulos_unificada" ON usuario_modulos
FOR DELETE TO authenticated USING (
   (SELECT public.es_super_admin())
   OR usuario_id IN (
       SELECT id FROM usuarios WHERE empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin())
   )
);



-- ===========================================
-- PARTE 9: CLIENTES
-- ===========================================

CREATE TABLE IF NOT EXISTS clientes (
    id bigint generated by default as identity primary key,
    empresa_id bigint references empresas(id) on delete cascade not null,
    sucursal_id bigint references sucursales(id) on delete set null, 
    nombre text not null,
    apellido text,
    email text,
    telefono text,
    direccion text,
    documento_identidad text, 
    razon_social text, 
    cuit text, 
    tipo_cliente text default 'persona', 
    notas text,
    estado text default 'activo', 
    fecha_creacion timestamp with time zone default timezone('utc'::text, now()) not null,
    actualizado_en timestamp with time zone default timezone('utc'::text, now()) not null
);

ALTER TABLE clientes ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.constraint_column_usage WHERE table_name = 'reclamos' AND constraint_name = 'reclamos_cliente_id_fkey') THEN
        ALTER TABLE reclamos ADD CONSTRAINT reclamos_cliente_id_fkey FOREIGN KEY (cliente_id) REFERENCES clientes(id) ON DELETE SET NULL;
    END IF;
END $$;

DROP POLICY IF EXISTS "Ver clientes de mi empresa/sucursal" ON clientes;
DROP POLICY IF EXISTS "Gestionar clientes propias" ON clientes;

DROP POLICY IF EXISTS "select_clientes_unificada" ON clientes;
CREATE POLICY "select_clientes_unificada" ON clientes
FOR SELECT TO authenticated USING (
  (empresa_id = (SELECT public.mi_empresa_id()) 
   AND (
     (SELECT public.es_admin()) 
     OR (sucursal_id IS NULL OR sucursal_id = (SELECT sucursal_id FROM public.usuarios WHERE id = (SELECT auth.uid())))
   )
  )
  OR (SELECT public.es_super_admin())
);

DROP POLICY IF EXISTS "insert_clientes_unificada" ON clientes;
CREATE POLICY "insert_clientes_unificada" ON clientes
FOR INSERT TO authenticated WITH CHECK (
  (empresa_id = (SELECT public.mi_empresa_id()) 
   AND (
     (SELECT public.es_admin()) 
     OR (sucursal_id IS NULL OR sucursal_id = (SELECT sucursal_id FROM public.usuarios WHERE id = (SELECT auth.uid())))
   )
  )
  OR (SELECT public.es_super_admin())
);

DROP POLICY IF EXISTS "update_clientes_unificada" ON clientes;
CREATE POLICY "update_clientes_unificada" ON clientes
FOR UPDATE TO authenticated USING (
  (empresa_id = (SELECT public.mi_empresa_id()) 
   AND (
     (SELECT public.es_admin()) 
     OR (sucursal_id IS NULL OR sucursal_id = (SELECT sucursal_id FROM public.usuarios WHERE id = (SELECT auth.uid())))
   )
  )
  OR (SELECT public.es_super_admin())
) WITH CHECK (
  (empresa_id = (SELECT public.mi_empresa_id()) 
   AND (
     (SELECT public.es_admin()) 
     OR (sucursal_id IS NULL OR sucursal_id = (SELECT sucursal_id FROM public.usuarios WHERE id = (SELECT auth.uid())))
   )
  )
  OR (SELECT public.es_super_admin())
);

DROP POLICY IF EXISTS "delete_clientes_unificada" ON clientes;
CREATE POLICY "delete_clientes_unificada" ON clientes
FOR DELETE TO authenticated USING (
  (empresa_id = (SELECT public.mi_empresa_id()) 
   AND (
     (SELECT public.es_admin()) 
     OR (sucursal_id IS NULL OR sucursal_id = (SELECT sucursal_id FROM public.usuarios WHERE id = (SELECT auth.uid())))
   )
  )
  OR (SELECT public.es_super_admin())
);

CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
   NEW.actualizado_en = now(); 
   RETURN NEW;
END;
$$ language 'plpgsql' SECURITY DEFINER SET search_path = pg_catalog, public;



DROP TRIGGER IF EXISTS update_clientes_modtime ON clientes;
CREATE TRIGGER update_clientes_modtime
    BEFORE UPDATE ON clientes
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- ===========================================
-- PARTE 10: FUNCIONES AVANZADAS (RPC)
-- Función de búsqueda cross-table (Reclamos + Clientes)
CREATE OR REPLACE FUNCTION buscar_reclamos(search_query text)
RETURNS SETOF public.reclamos
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = pg_catalog, public
AS $$
  SELECT r.*
  FROM public.reclamos r
  LEFT JOIN public.clientes c ON r.cliente_id = c.id
  WHERE
    r.titulo ILIKE '%' || search_query || '%'
    OR r.descripcion ILIKE '%' || search_query || '%'
    OR c.nombre ILIKE '%' || search_query || '%'
    OR c.apellido ILIKE '%' || search_query || '%'
    OR c.razon_social ILIKE '%' || search_query || '%';
$$;


-- ===========================================
-- PARTE 11: DATOS SEMILLA (DEMO)
-- ===========================================

INSERT INTO empresas (nombre, codigo, color_tema) VALUES ('Mi Empresa Demo', 'demo', '#4CAF50') ON CONFLICT DO NOTHING;

-- Seed Super Admin (if auth user exists)
DO $$
DECLARE
  v_user_id uuid;
  v_role_id integer;
BEGIN
  -- Get super_admin role id
  SELECT id INTO v_role_id FROM public.roles WHERE nombre = 'super_admin' LIMIT 1;

  -- Intentar encontrar el usuario por email (creado previamente en Auth)
  SELECT id INTO v_user_id FROM auth.users WHERE email = 'admin@ejemplo.com';
  
  IF v_user_id IS NOT NULL AND v_role_id IS NOT NULL THEN
    INSERT INTO public.usuarios (id, email, nombre, rol_id, empresa_id, tipo_perfil)
    VALUES (v_user_id, 'admin@ejemplo.com', 'Super Admin', v_role_id, NULL, 'super_admin')
    ON CONFLICT (id) DO UPDATE SET rol_id = v_role_id, tipo_perfil = 'super_admin';
  END IF;
END $$;

-- ===========================================
-- PARTE 12: OPTIMIZACIÓN DE PERFORMANCE (INDICES)
-- ===========================================

-- 1. Usuarios
CREATE INDEX IF NOT EXISTS idx_usuarios_rol_id ON usuarios(rol_id);
CREATE INDEX IF NOT EXISTS idx_usuarios_empresa_id ON usuarios(empresa_id);
CREATE INDEX IF NOT EXISTS idx_usuarios_sucursal_id ON usuarios(sucursal_id);

-- 2. Invitaciones
CREATE INDEX IF NOT EXISTS idx_invitaciones_empresa_id ON invitaciones(empresa_id);
CREATE INDEX IF NOT EXISTS idx_invitaciones_rol_id ON invitaciones(rol_id);
CREATE INDEX IF NOT EXISTS idx_invitaciones_email ON invitaciones(email);

-- 3. Roles/Permisos
CREATE INDEX IF NOT EXISTS idx_usuario_permiso_permiso_id ON usuario_permiso(permiso_id);
CREATE INDEX IF NOT EXISTS idx_rol_capacidad_capacidad_id ON rol_capacidad(capacidad_id);

-- 4. Reclamos
CREATE INDEX IF NOT EXISTS idx_reclamos_empresa_id ON reclamos(empresa_id);
CREATE INDEX IF NOT EXISTS idx_reclamos_sucursal_id ON reclamos(sucursal_id);
CREATE INDEX IF NOT EXISTS idx_reclamos_usuario_id ON reclamos(usuario_id);
CREATE INDEX IF NOT EXISTS idx_reclamos_cliente_id ON reclamos(cliente_id);
CREATE INDEX IF NOT EXISTS idx_reclamos_estado ON reclamos(estado);
CREATE INDEX IF NOT EXISTS idx_historial_reclamo_id ON historial_reclamos(reclamo_id);

-- 5. Interacciones
CREATE INDEX IF NOT EXISTS idx_interacciones_empresa_id ON interacciones(empresa_id);
CREATE INDEX IF NOT EXISTS idx_interacciones_usuario_id ON interacciones(usuario_id);

-- 6. Clientes
CREATE INDEX IF NOT EXISTS idx_clientes_empresa_id ON clientes(empresa_id);
CREATE INDEX IF NOT EXISTS idx_clientes_sucursal_id ON clientes(sucursal_id);
CREATE INDEX IF NOT EXISTS idx_clientes_documento ON clientes(documento_identidad);

-- 7. Modulos
CREATE INDEX IF NOT EXISTS idx_empresa_modulos_modulo_id ON empresa_modulos(modulo_id);
CREATE INDEX IF NOT EXISTS idx_sucursal_modulos_sucursal_id ON sucursal_modulos(sucursal_id);
CREATE INDEX IF NOT EXISTS idx_usuario_modulos_usuario_id ON usuario_modulos(usuario_id);




-- ========================================
-- EXPANDED THEMING SYSTEM (2025-12-13)
-- ========================================
-- Agregar más opciones de personalización de theming

-- Colores adicionales para light mode
ALTER TABLE empresa_branding ADD COLUMN IF NOT EXISTS color_fondo VARCHAR(7) DEFAULT '#FFFFFF';
ALTER TABLE empresa_branding ADD COLUMN IF NOT EXISTS color_texto VARCHAR(7) DEFAULT '#1F2937';
ALTER TABLE empresa_branding ADD COLUMN IF NOT EXISTS color_error VARCHAR(7) DEFAULT '#EF4444';
ALTER TABLE empresa_branding ADD COLUMN IF NOT EXISTS color_exito VARCHAR(7) DEFAULT '#10B981';
ALTER TABLE empresa_branding ADD COLUMN IF NOT EXISTS color_advertencia VARCHAR(7) DEFAULT '#F59E0B';
ALTER TABLE empresa_branding ADD COLUMN IF NOT EXISTS color_info VARCHAR(7) DEFAULT '#3B82F6';

-- Colores adicionales para dark mode
ALTER TABLE empresa_branding ADD COLUMN IF NOT EXISTS color_fondo_dark VARCHAR(7) DEFAULT '#1F2937';
ALTER TABLE empresa_branding ADD COLUMN IF NOT EXISTS color_texto_dark VARCHAR(7) DEFAULT '#F9FAFB';
ALTER TABLE empresa_branding ADD COLUMN IF NOT EXISTS color_error_dark VARCHAR(7) DEFAULT '#F87171';
ALTER TABLE empresa_branding ADD COLUMN IF NOT EXISTS color_exito_dark VARCHAR(7) DEFAULT '#34D399';
ALTER TABLE empresa_branding ADD COLUMN IF NOT EXISTS color_advertencia_dark VARCHAR(7) DEFAULT '#FBBF24';
ALTER TABLE empresa_branding ADD COLUMN IF NOT EXISTS color_info_dark VARCHAR(7) DEFAULT '#60A5FA';

-- Tipografía avanzada
ALTER TABLE empresa_branding ADD COLUMN IF NOT EXISTS fuente_secundaria VARCHAR(100) DEFAULT 'Roboto';
ALTER TABLE empresa_branding ADD COLUMN IF NOT EXISTS tamano_texto_base INTEGER DEFAULT 16;
ALTER TABLE empresa_branding ADD COLUMN IF NOT EXISTS tamano_header INTEGER DEFAULT 28;

-- Espaciado y bordes
ALTER TABLE empresa_branding ADD COLUMN IF NOT EXISTS espaciado_base INTEGER DEFAULT 16;
ALTER TABLE empresa_branding ADD COLUMN IF NOT EXISTS radio_bordes INTEGER DEFAULT 8;

-- Comentarios
COMMENT ON COLUMN empresa_branding.color_fondo IS 'Color de fondo principal (light mode)';
COMMENT ON COLUMN empresa_branding.color_texto IS 'Color de texto principal (light mode)';
COMMENT ON COLUMN empresa_branding.fuente_secundaria IS 'Fuente utilizada para headers y títulos';


-- ==========================================
-- TRANSCRIPCIONES EJECUTIVO (Speech-to-Text)
-- Fecha: 2025-12-15
-- ==========================================
CREATE TABLE transcripciones_ejecutivo (
  id BIGSERIAL PRIMARY KEY,
  
  -- Metadata básica
  fecha_creacion TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  empresa_id BIGINT NOT NULL,
  sucursal_id BIGINT,
  
  -- Ejecutivo que hizo la grabación
  ejecutivo_id UUID NOT NULL,
  ejecutivo_nombre TEXT NOT NULL,
  ejecutivo_rol TEXT,
  
  -- Cliente relacionado (opcional, al menos uno de cliente o reclamo debe existir)
  cliente_id BIGINT,
  cliente_nombre TEXT,
  cliente_telefono TEXT,
  cliente_email TEXT,
  
  -- Reclamo relacionado (opcional)
  reclamo_id BIGINT,
  
  -- Tipo de grabación
  tipo_grabacion TEXT NOT NULL DEFAULT 'nota_voz' CHECK (tipo_grabacion IN ('nota_voz', 'conversacion')),
  
  -- Transcripción del audio
  texto_transcrito TEXT NOT NULL,
  confidence DECIMAL(5,4), -- 0.0000 - 1.0000 (confianza de Whisper)
  duracion_segundos DECIMAL(8,2),
  idioma_detectado TEXT DEFAULT 'es',
  
  -- Diarización (solo para tipo 'conversacion')
  segmentos_conversacion JSONB, -- Array de {speaker, start, end, text, confidence}
  participantes JSONB, -- Array de {speaker_id, role, nombre, voice_embedding}
  num_speakers INT, -- Número de speakers detectados
  
  -- Análisis de IA (generado por backend Python)
  productos_sugeridos JSONB, -- Array de {nombre, categoria, score, razon}
  palabras_clave TEXT[], -- Keywords extraídas
  sentimiento TEXT CHECK (sentimiento IN ('positivo', 'neutral', 'negativo')),
  prioridad TEXT CHECK (prioridad IN ('alta', 'media', 'baja')),
  analisis_completo JSONB, -- Resultado completo del análisis de IA
  fecha_analisis TIMESTAMPTZ,
  
  -- Búsqueda de texto completo
  busqueda_vector TSVECTOR GENERATED ALWAYS AS (
    to_tsvector('spanish', texto_transcrito)
  ) STORED,
  
  -- Soft delete
  eliminado BOOLEAN DEFAULT FALSE,
  fecha_eliminado TIMESTAMPTZ,
  
  -- Foreign Keys
  CONSTRAINT fk_transcripciones_empresa 
    FOREIGN KEY (empresa_id) REFERENCES empresas(id) ON DELETE CASCADE,
  CONSTRAINT fk_transcripciones_sucursal 
    FOREIGN KEY (sucursal_id) REFERENCES sucursales(id) ON DELETE SET NULL,
  CONSTRAINT fk_transcripciones_ejecutivo 
    FOREIGN KEY (ejecutivo_id) REFERENCES usuarios(id) ON DELETE CASCADE,
  CONSTRAINT fk_transcripciones_cliente 
    FOREIGN KEY (cliente_id) REFERENCES clientes(id) ON DELETE SET NULL,
  CONSTRAINT fk_transcripciones_reclamo 
    FOREIGN KEY (reclamo_id) REFERENCES reclamos(id) ON DELETE SET NULL,
    
  -- Al menos uno de cliente o reclamo debe estar presente
  CONSTRAINT check_cliente_o_reclamo
    CHECK (cliente_id IS NOT NULL OR reclamo_id IS NOT NULL)
);

-- ============================================================================
-- ÍNDICES PARA PERFORMANCE
-- ============================================================================

-- Índice por empresa (más común)
CREATE INDEX idx_transcripciones_empresa 
  ON transcripciones_ejecutivo(empresa_id) 
  WHERE eliminado = FALSE;

-- Índice por ejecutivo
CREATE INDEX idx_transcripciones_ejecutivo 
  ON transcripciones_ejecutivo(ejecutivo_id) 
  WHERE eliminado = FALSE;

-- Índice por cliente
CREATE INDEX idx_transcripciones_cliente 
  ON transcripciones_ejecutivo(cliente_id) 
  WHERE cliente_id IS NOT NULL AND eliminado = FALSE;

-- Índice por reclamo
CREATE INDEX idx_transcripciones_reclamo 
  ON transcripciones_ejecutivo(reclamo_id) 
  WHERE reclamo_id IS NOT NULL AND eliminado = FALSE;

-- Índice por fecha (para ordenamiento y filtros temporales)
CREATE INDEX idx_transcripciones_fecha 
  ON transcripciones_ejecutivo(fecha_creacion DESC) 
  WHERE eliminado = FALSE;

-- Índice de búsqueda de texto completo
CREATE INDEX idx_transcripciones_busqueda 
  ON transcripciones_ejecutivo 
  USING GIN(busqueda_vector);

-- Índice JSONB para productos sugeridos
CREATE INDEX idx_transcripciones_productos 
  ON transcripciones_ejecutivo 
  USING GIN(productos_sugeridos);

-- Índice para palabras clave
CREATE INDEX idx_transcripciones_keywords 
  ON transcripciones_ejecutivo 
  USING GIN(palabras_clave);

-- Índice para segmentos de conversación
CREATE INDEX idx_transcripciones_segmentos 
  ON transcripciones_ejecutivo 
  USING GIN(segmentos_conversacion);

-- Índice para participantes
CREATE INDEX idx_transcripciones_participantes 
  ON transcripciones_ejecutivo 
  USING GIN(participantes);

-- ============================================================================
-- ROW LEVEL SECURITY (RLS) - Seguridad a nivel de fila
-- ============================================================================

ALTER TABLE transcripciones_ejecutivo ENABLE ROW LEVEL SECURITY;

-- Policy: Los usuarios solo pueden VER transcripciones de su empresa
CREATE POLICY transcripciones_select_policy ON transcripciones_ejecutivo
  FOR SELECT
  USING (
    eliminado = FALSE
    AND empresa_id IN (
      SELECT empresa_id 
      FROM usuarios 
      WHERE id = auth.uid()
    )
  );

-- Policy: Solo el ejecutivo propietario puede CREAR (INSERT)
CREATE POLICY transcripciones_insert_policy ON transcripciones_ejecutivo
  FOR INSERT
  WITH CHECK (
    ejecutivo_id = auth.uid()
    AND empresa_id IN (
      SELECT empresa_id 
      FROM usuarios 
      WHERE id = auth.uid()
    )
  );

-- Policy: Solo el ejecutivo propietario o admin puede ACTUALIZAR
CREATE POLICY transcripciones_update_policy ON transcripciones_ejecutivo
  FOR UPDATE
  USING (
    eliminado = FALSE
    AND (
      ejecutivo_id = auth.uid() 
      OR EXISTS (
        SELECT 1 FROM usuarios 
        WHERE id = auth.uid() 
        AND tipo_perfil IN ('admin', 'super_admin')
        AND empresa_id = transcripciones_ejecutivo.empresa_id
      )
    )
  );

-- Policy: Solo admin puede hacer soft delete
CREATE POLICY transcripciones_delete_policy ON transcripciones_ejecutivo
  FOR UPDATE
  USING (
    NOT eliminado
    AND EXISTS (
      SELECT 1 FROM usuarios 
      WHERE id = auth.uid() 
      AND tipo_perfil IN ('admin', 'super_admin')
      AND empresa_id = transcripciones_ejecutivo.empresa_id
    )
  )
  WITH CHECK (
    eliminado = TRUE
    AND fecha_eliminado IS NOT NULL
  );

-- ============================================================================
-- FUNCIONES AUXILIARES
-- ============================================================================

-- Función para buscar transcripciones por texto
CREATE OR REPLACE FUNCTION buscar_transcripciones(
  p_empresa_id BIGINT,
  p_query TEXT,
  p_limit INT DEFAULT 50
)
RETURNS TABLE (
  id BIGINT,
  fecha_creacion TIMESTAMPTZ,
  ejecutivo_nombre TEXT,
  cliente_nombre TEXT,
  texto_transcrito TEXT,
  productos_sugeridos JSONB,
  rank REAL
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    t.id,
    t.fecha_creacion,
    t.ejecutivo_nombre,
    t.cliente_nombre,
    t.texto_transcrito,
    t.productos_sugeridos,
    ts_rank(t.busqueda_vector, to_tsquery('spanish', p_query)) as rank
  FROM transcripciones_ejecutivo t
  WHERE 
    t.empresa_id = p_empresa_id
    AND t.eliminado = FALSE
    AND t.busqueda_vector @@ to_tsquery('spanish', p_query)
  ORDER BY rank DESC
  LIMIT p_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Función para obtener estadísticas de transcripciones por ejecutivo
CREATE OR REPLACE FUNCTION stats_transcripciones_ejecutivo(
  p_empresa_id BIGINT,
  p_fecha_inicio TIMESTAMPTZ DEFAULT NOW() - INTERVAL '30 days',
  p_fecha_fin TIMESTAMPTZ DEFAULT NOW()
)
RETURNS TABLE (
  ejecutivo_id UUID,
  ejecutivo_nombre TEXT,
  total_transcripciones INT,
  total_clientes_unicos INT,
  promedio_confidence DECIMAL,
  productos_mas_sugeridos JSONB
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    t.ejecutivo_id,
    t.ejecutivo_nombre,
    COUNT(*)::INT as total_transcripciones,
    COUNT(DISTINCT t.cliente_id)::INT as total_clientes_unicos,
    AVG(t.confidence) as promedio_confidence,
    jsonb_agg(DISTINCT elem) FILTER (WHERE elem IS NOT NULL) as productos_mas_sugeridos
  FROM transcripciones_ejecutivo t,
       jsonb_array_elements(t.productos_sugeridos) elem
  WHERE 
    t.empresa_id = p_empresa_id
    AND t.eliminado = FALSE
    AND t.fecha_creacion BETWEEN p_fecha_inicio AND p_fecha_fin
  GROUP BY t.ejecutivo_id, t.ejecutivo_nombre
  ORDER BY total_transcripciones DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- GRANTS - Permisos
-- ============================================================================

-- Dar permisos a usuarios autenticados
GRANT SELECT, INSERT, UPDATE ON transcripciones_ejecutivo TO authenticated;
GRANT USAGE, SELECT ON SEQUENCE transcripciones_ejecutivo_id_seq TO authenticated;

-- Dar permisos de ejecución a funciones
GRANT EXECUTE ON FUNCTION buscar_transcripciones(BIGINT, TEXT, INT) TO authenticated;
GRANT EXECUTE ON FUNCTION stats_transcripciones_ejecutivo(BIGINT, TIMESTAMPTZ, TIMESTAMPTZ) TO authenticated;

-- ============================================================================
-- COMENTARIOS - Documentación
-- ============================================================================

COMMENT ON TABLE transcripciones_ejecutivo IS 
  'Almacena transcripciones de audio de ejecutivos con análisis de IA. Soporta dos modos: notas de voz simples y conversaciones con speaker diarization';

COMMENT ON COLUMN transcripciones_ejecutivo.texto_transcrito IS 
  'Texto transcrito por Whisper desde el audio grabado por el ejecutivo';

COMMENT ON COLUMN transcripciones_ejecutivo.productos_sugeridos IS 
  'Array JSON de productos sugeridos por IA: [{nombre, categoria, score, razon}]';

COMMENT ON COLUMN transcripciones_ejecutivo.busqueda_vector IS 
  'Vector de búsqueda de texto completo generado automáticamente';

COMMENT ON FUNCTION buscar_transcripciones IS 
  'Busca transcripciones usando búsqueda de texto completo en español';

COMMENT ON FUNCTION stats_transcripciones_ejecutivo IS 
  'Retorna estadísticas agregadas de transcripciones por ejecutivo en un rango de fechas';

-- ============================================================================
-- VOICE PROFILES - Speaker Recognition (Diarization Enhancement)
-- Fecha: 2025-12-16
-- ============================================================================

-- Habilitar pgvector extension (requiere permisos de super admin en Supabase)
-- CREATE EXTENSION IF NOT EXISTS vector;

-- Comentario: En Supabase, la extensión pgvector debe habilitarse desde el panel de administración
-- SQL Editor -> Extensions -> Enable "vector"

CREATE TABLE IF NOT EXISTS voice_profiles (
  id BIGSERIAL PRIMARY KEY,
  
  -- Usuario o cliente asociado
  user_id UUID REFERENCES usuarios(id) ON DELETE CASCADE,
  cliente_id BIGINT REFERENCES clientes(id) ON DELETE CASCADE,
  
  -- Empresa (multi-tenant)
  empresa_id BIGINT NOT NULL REFERENCES empresas(id) ON DELETE CASCADE,
  
  -- Voice embedding (vector de características de voz)
  -- Comentado hasta que pgvector esté habilitado
  -- embedding VECTOR(512),  -- Pyannote genera embeddings de 512 dimensiones
  embedding_json JSONB,  -- Alternativa temporal: guardar como JSON array
  
  -- Metadata del sample de audio
  sample_audio_path TEXT,
  sample_duration_seconds DECIMAL(8,2),
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  -- Confianza y estadísticas
  samples_count INT DEFAULT 1,  -- Número de samples usados para crear el perfil
  confidence_score DECIMAL(3,2),  -- Confianza del embedding (0.00 - 1.00)
  
  -- Constraints
  CONSTRAINT voice_profile_user_or_cliente CHECK (
    user_id IS NOT NULL OR cliente_id IS NOT NULL
  ),
  CONSTRAINT voice_profile_unique_user UNIQUE (user_id),
  CONSTRAINT voice_profile_unique_cliente UNIQUE (cliente_id)
);

-- Índices
CREATE INDEX idx_voice_profiles_empresa ON voice_profiles(empresa_id);
CREATE INDEX idx_voice_profiles_user ON voice_profiles(user_id) WHERE user_id IS NOT NULL;
CREATE INDEX idx_voice_profiles_cliente ON voice_profiles(cliente_id) WHERE cliente_id IS NOT NULL;

-- Index para búsqueda por similitud (cuando pgvector esté habilitado)
-- CREATE INDEX idx_voice_profiles_embedding 
-- ON voice_profiles 
-- USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);

-- RLS
ALTER TABLE voice_profiles ENABLE ROW LEVEL SECURITY;

CREATE POLICY voice_profiles_select_policy ON voice_profiles
  FOR SELECT
  USING (
    empresa_id IN (
      SELECT empresa_id 
      FROM usuarios 
      WHERE id = auth.uid()
    )
  );

CREATE POLICY voice_profiles_insert_policy ON voice_profiles
  FOR INSERT
  WITH CHECK (
    empresa_id IN (
      SELECT empresa_id 
      FROM usuarios 
      WHERE id = auth.uid()
    )
    AND (
      user_id = auth.uid()  -- Solo puede crear su propio perfil
      OR EXISTS (  -- O admin puede crear perfiles de clientes
        SELECT 1 FROM usuarios 
        WHERE id = auth.uid() 
        AND tipo_perfil IN ('admin', 'super_admin')
      )
    )
  );

CREATE POLICY voice_profiles_update_policy ON voice_profiles
  FOR UPDATE
  USING (
    user_id = auth.uid() 
    OR EXISTS (
      SELECT 1 FROM usuarios 
      WHERE id = auth.uid() 
      AND tipo_perfil IN ('admin', 'super_admin')
      AND empresa_id = voice_profiles.empresa_id
    )
  );

CREATE POLICY voice_profiles_delete_policy ON voice_profiles
  FOR DELETE
  USING (
    EXISTS (
      SELECT 1 FROM usuarios 
      WHERE id = auth.uid() 
      AND tipo_perfil IN ('admin', 'super_admin')
      AND empresa_id = voice_profiles.empresa_id
    )
  );

-- Permisos
GRANT SELECT, INSERT, UPDATE ON voice_profiles TO authenticated;
GRANT USAGE, SELECT ON SEQUENCE voice_profiles_id_seq TO authenticated;

-- Comentarios
COMMENT ON TABLE voice_profiles IS 
  'Perfiles de voz para speaker recognition. Almacena embeddings de voz de usuarios y clientes para mejorar la precisión de diarización';

COMMENT ON COLUMN voice_profiles.embedding_json IS 
  'Embedding de voz almacenado como JSON array. Se migrará a tipo VECTOR cuando pgvector esté habilitado';

-- ============================================================================
-- MODULE ACTIVATION SYSTEM - Facturación por Módulos
-- Fecha: 2025-12-16
-- ============================================================================

-- Tabla de módulos disponibles (catálogo)
CREATE TABLE IF NOT EXISTS available_modules (
  id SERIAL PRIMARY KEY,
  module_key VARCHAR(50) UNIQUE NOT NULL,
  module_name VARCHAR(100) NOT NULL,
  description TEXT,
  monthly_price DECIMAL(10,2) DEFAULT 0.00,
  requires_backend BOOLEAN DEFAULT FALSE,  -- Si requiere servicios backend adicionales
  icon VARCHAR(50),
  category VARCHAR(50),  -- 'core', 'optional', 'premium'
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabla de módulos activados por empresa
CREATE TABLE IF NOT EXISTS modules_enabled (
  id BIGSERIAL PRIMARY KEY,
  empresa_id BIGINT NOT NULL REFERENCES empresas(id) ON DELETE CASCADE,
  module_key VARCHAR(50) NOT NULL REFERENCES available_modules(module_key) ON DELETE CASCADE,
  
  -- Estado
  enabled BOOLEAN DEFAULT TRUE,
  activated_at TIMESTAMPTZ DEFAULT NOW(),
  deactivated_at TIMESTAMPTZ,
  
  -- Billing
  billing_cycle VARCHAR(20) DEFAULT 'monthly',  -- 'monthly', 'yearly'
  custom_price DECIMAL(10,2),  -- Precio personalizado (override del precio base)
  
  -- Limits
  usage_limit INT,  -- Límite de uso mensual (ej: 1000 transcripciones)
  
  -- Metadata
  config JSONB DEFAULT '{}',  -- Configuración específica del módulo
  
  CONSTRAINT modules_enabled_unique UNIQUE(empresa_id, module_key)
);

-- Tabla de tracking de uso de módulos
CREATE TABLE IF NOT EXISTS module_usage (
  id BIGSERIAL PRIMARY KEY,
  empresa_id BIGINT NOT NULL REFERENCES empresas(id) ON DELETE CASCADE,
  module_key VARCHAR(50) NOT NULL,
  
  -- Tracking temporal
  usage_date DATE NOT NULL DEFAULT CURRENT_DATE,
  usage_count INT DEFAULT 0,
  
  -- Metadata adicional
  user_id UUID REFERENCES usuarios(id) ON DELETE SET NULL,  -- Usuario que generó el uso
  metadata JSONB DEFAULT '{}',  -- Datos específicos del uso
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  CONSTRAINT module_usage_unique UNIQUE(empresa_id, module_key, usage_date, user_id)
);

-- Índices
CREATE INDEX idx_modules_enabled_empresa ON modules_enabled(empresa_id);
CREATE INDEX idx_modules_enabled_module ON modules_enabled(module_key);
CREATE INDEX idx_modules_enabled_active ON modules_enabled(empresa_id, enabled) WHERE enabled = TRUE;

CREATE INDEX idx_module_usage_empresa ON module_usage(empresa_id);
CREATE INDEX idx_module_usage_date ON module_usage(usage_date DESC);
CREATE INDEX idx_module_usage_module ON module_usage(module_key);
CREATE INDEX idx_module_usage_user ON module_usage(user_id) WHERE user_id IS NOT NULL;

-- RLS
ALTER TABLE available_modules ENABLE ROW LEVEL SECURITY;
ALTER TABLE modules_enabled ENABLE ROW LEVEL SECURITY;
ALTER TABLE module_usage ENABLE ROW LEVEL SECURITY;

-- Policies: available_modules (catálogo público)
CREATE POLICY available_modules_select_policy ON available_modules
  FOR SELECT
  USING (true);  -- Todos pueden ver el catálogo

CREATE POLICY available_modules_manage_policy ON available_modules
  FOR ALL
  USING ((SELECT public.es_super_admin()))
  WITH CHECK ((SELECT public.es_super_admin()));

-- Policies: modules_enabled
CREATE POLICY modules_enabled_select_policy ON modules_enabled
  FOR SELECT
  USING (
    empresa_id = (SELECT public.mi_empresa_id())
    OR (SELECT public.es_super_admin())
  );

CREATE POLICY modules_enabled_insert_policy ON modules_enabled
  FOR INSERT
  WITH CHECK (
    (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin()))
    OR (SELECT public.es_super_admin())
  );

CREATE POLICY modules_enabled_update_policy ON modules_enabled
  FOR UPDATE
  USING (
    (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin()))
    OR (SELECT public.es_super_admin())
  )
  WITH CHECK (
    (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin()))
    OR (SELECT public.es_super_admin())
  );

CREATE POLICY modules_enabled_delete_policy ON modules_enabled
  FOR DELETE
  USING (
    (empresa_id = (SELECT public.mi_empresa_id()) AND (SELECT public.es_admin()))
    OR (SELECT public.es_super_admin())
  );

-- Policies: module_usage
CREATE POLICY module_usage_select_policy ON module_usage
  FOR SELECT
  USING (
    empresa_id = (SELECT public.mi_empresa_id())
    OR (SELECT public.es_super_admin())
  );

CREATE POLICY module_usage_insert_policy ON module_usage
  FOR INSERT
  WITH CHECK (
    empresa_id = (SELECT public.mi_empresa_id())
  );

-- Permisos
GRANT SELECT ON available_modules TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON modules_enabled TO authenticated;
GRANT SELECT, INSERT ON module_usage TO authenticated;
GRANT USAGE, SELECT ON SEQUENCE modules_enabled_id_seq TO authenticated;
GRANT USAGE, SELECT ON SEQUENCE module_usage_id_seq TO authenticated;

-- Seed data: Módulos disponibles
INSERT INTO available_modules (module_key, module_name, description, monthly_price, requires_backend, icon, category) VALUES
  ('speech_to_text', 'Speech-to-Text', 'Transcripción de audio con IA y speaker diarization', 40.00, TRUE, 'mic', 'premium'),
  ('advanced_analytics', 'Analytics Avanzado', 'Dashboard con insights y gráficos avanzados', 25.00, FALSE, 'analytics', 'optional'),
  ('whatsapp', 'WhatsApp Integration', 'Integración con WhatsApp Business API', 40.00, TRUE, 'chat', 'premium'),
  ('email_automation', 'Email Automation', 'Envío automático de emails y templates', 15.00, TRUE, 'email', 'optional'),
  ('api_access', 'API Access', 'Acceso a API REST para integraciones', 30.00, TRUE, 'code', 'premium')
ON CONFLICT (module_key) DO NOTHING;

-- Función helper: Verificar si módulo está activo para empresa
CREATE OR REPLACE FUNCTION is_module_enabled(
  p_empresa_id BIGINT,
  p_module_key VARCHAR(50)
)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM modules_enabled
    WHERE empresa_id = p_empresa_id
    AND module_key = p_module_key
    AND enabled = TRUE
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION is_module_enabled(BIGINT, VARCHAR) TO authenticated;

-- Función: Registrar uso de módulo
CREATE OR REPLACE FUNCTION track_module_usage(
  p_empresa_id BIGINT,
  p_module_key VARCHAR(50),
  p_user_id UUID DEFAULT NULL,
  p_metadata JSONB DEFAULT '{}'
)
RETURNS VOID AS $$
BEGIN
  INSERT INTO module_usage (empresa_id, module_key, user_id, usage_count, metadata)
  VALUES (p_empresa_id, p_module_key, p_user_id, 1, p_metadata)
  ON CONFLICT (empresa_id, module_key, usage_date, user_id)
  DO UPDATE SET 
    usage_count = module_usage.usage_count + 1,
    metadata = module_usage.metadata || p_metadata;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION track_module_usage(BIGINT, VARCHAR, UUID, JSONB) TO authenticated;

-- Función: Obtener uso mensual de módulo
CREATE OR REPLACE FUNCTION get_module_monthly_usage(
  p_empresa_id BIGINT,
  p_module_key VARCHAR(50),
  p_month DATE DEFAULT CURRENT_DATE
)
RETURNS TABLE (
  usage_date DATE,
  total_usage BIGINT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    mu.usage_date,
    SUM(mu.usage_count) as total_usage
  FROM module_usage mu
  WHERE 
    mu.empresa_id = p_empresa_id
    AND mu.module_key = p_module_key
    AND mu.usage_date >= DATE_TRUNC('month', p_month)
    AND mu.usage_date < DATE_TRUNC('month', p_month) + INTERVAL '1 month'
  GROUP BY mu.usage_date
  ORDER BY mu.usage_date;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION get_module_monthly_usage(BIGINT, VARCHAR, DATE) TO authenticated;

-- Comentarios
COMMENT ON TABLE available_modules IS 
  'Catálogo de módulos opcionales disponibles para activar';

COMMENT ON TABLE modules_enabled IS 
  'Módulos activados por empresa con configuración y límites';

COMMENT ON TABLE module_usage IS 
  'Tracking de uso diario de módulos para facturación y analytics';

COMMENT ON FUNCTION is_module_enabled IS 
  'Verifica si un módulo está activo para una empresa';

COMMENT ON FUNCTION track_module_usage IS 
  'Registra el uso de un módulo incrementando el contador diario';

COMMENT ON FUNCTION get_module_monthly_usage IS 
  'Obtiene el uso agregado de un módulo para un mes específico';

-- ============================================================================
-- UPDATE METADATA COLUMN FOR TRANSCRIPCIONES
-- Agregar campo metadata para guardar contexto (clienteId, ejecutivoId)
-- ============================================================================

ALTER TABLE transcripciones_ejecutivo 
ADD COLUMN IF NOT EXISTS metadata JSONB DEFAULT '{}';

CREATE INDEX IF NOT EXISTS idx_transcripciones_metadata 
ON transcripciones_ejecutivo USING GIN(metadata);

COMMENT ON COLUMN transcripciones_ejecutivo.metadata IS 
  'Metadata adicional incluyendo contexto de diarización (clienteId, ejecutivoId pasados en request)';
